function U = zernfun_cart(coord_x, coord_y, n, m, truncate)
% Authour: Giulia Sereni
% Purpose: calculate the zernike functions described 
% in "Efficient cartesian representation of zernike polynomials in 
% computer memory. Hedser H. van Brug. Proc. SPIE 3190, (1997). 
% doi: 10.1117/12.294412"
% 
% INPUT
% coord_x = from -1 to +1. [1 x N] array. 
% coord_y = from -1 to +1. [N x 1] array.
% n = the radial order of the zernike function generated by the 
% 'zernike_order' function, [1xnumber of modes] array
% m = the azimuthal order generated by the 'zernike_order' function, 
% [1xnumber of modes] array.
% truncate = if true, the function uses the zernike function within the unit 
% circle as input for the derivate (outside the circle the function is zero), 
% if false it uses the whole zernike function. see 'zerfun_cart' function.
%
% OUTPUT
% U = zernike function for a given n and m whose size is given by the
% coord_x and coord_y. it is a square matrix.


    if nargin < 5
        truncate = true; %default
    end

    validateattributes(n, {'numeric'}, {'nonnegative'});
    validateattributes(m, {'numeric'}, {'nonnegative'});
    
    % if n and m are arrays, construct zernike modes for each entry in n
    % and store them in a multi-dimensional array
    if ~isscalar(n)
        validateattributes(m, {'numeric'}, {'size', size(m)});
        U = zeros([numel(coord_y), numel(coord_x), numel(m)]);
        for j=1:numel(m)
            U(:,:,j) = zernfun_cart(coord_y, coord_x, n(j), m(j), truncate);
        end
        return 
    end
    validateattributes(truncate, {'logical'}, {'scalar'});

    if m>n
        error('zernfun_cart:MlessthanN', ...
              'Each m must be less than or equal to its corresponding n.')
    end

    l=n-2*m;

    if l>0
        p=1;
    else
        p=0;
    end


    if l>0 && mod(n,2)==0
        q=abs(l)/2-1;
    elseif l<=0 && mod(n,2)==0
        q=abs(l)/2;
    elseif mod(n,2)~=0
        q=(abs(l)-1)/2;
    end

    x=reshape(coord_x, [1, numel(coord_x)]);
    y=reshape(coord_y, [numel(coord_y), 1]);

    M=(n-abs(l))/2;
    U=zeros(length(y),length(x));

    for r=0:q
       for j=0:M
           sign = ((-1)^(r+j));
           for k=0:(M-j)
              U = U + sign * ...
                  (nchoosek(abs(l),2*r+p)*nchoosek(M-j,k))*((factorial(n-j))/(factorial(j)*factorial(M-j)*factorial(n-M-j)))*   ...
                  (x.^(n-2*(r+j+k)-p) .* y.^(2*(r+k)+p));
            end
       end
    end

    if truncate
        U((x.^2 + y.^2) > 1) = 0;
    end

end


